#!/usr/bin/env python3

# Пример "Наследования":
class Hero:
    def __init__(self, name):
        self.name = name

    def introduce(self):
        return f"Я {self.name}, герой."

class Warrior(Hero):
    def __init__(self, name, sword):
        super().__init__(name)
        self.sword = sword

    def attack(self):
        return f"{self.name} атакует с помощью меча '{self.sword.name}'!"

class Mage(Hero):
    def __init__(self, name, staff):
        super().__init__(name)
        self.staff = staff

    def cast_spell(self):
        return f"{self.name} колдует с помощью посоха '{self.staff.name}'!"

# Пример "Комозиции":

class Sword:
    def __init__(self, name):
        self.name = name

class IceStaff:
    def __init__(self, name):
        self.name = name

class FireStaff:
    def __init__(self, name):
        self.name = name

class PoisonStaff:
    def __init__(self, name):
        self.name = name

# Использование
sword = Sword("Кладенец")
warrior = Warrior("Илья Муромец", sword)

ice_staff = IceStaff("Ледяное дыхание")
fire_staff = FireStaff("Огненный шар")
poison_staff = PoisonStaff("Ядовитый шип")
mage = Mage("Кощей Бессмертный", ice_staff)

print(warrior.introduce())  # Я Илья Муромец, герой.
print(warrior.attack())     # Илья Муромец атакует с помощью меча 'Кладенец'!

print(mage.introduce())     # Я Кощей Бессмертный, герой.
print(mage.cast_spell())    # Кощей Бессмертный колдует с помощью посоха
                            #'Ледяное дыхание'!

""" Объяснение

    Наследование: Классы Warrior и Mage наследуются от класса Hero, что
    позволяет им использовать метод introduce и расширять его своими методами
    (attack для Warrior и cast_spell для Mage).

    Композиция: Класс Warrior имеет Sword, а класс Mage может иметь различные
    типы посохов (IceStaff, FireStaff, PoisonStaff). Это позволяет классам
    Warrior и Mage использовать функциональность этих классов оружия без
    необходимости наследования от них.

    Эта структура демонстрирует, как наследование и композиция могут
    использоваться вместе для создания гибкого и повторно используемого кода.
    """

""" ПОДРОБНОЕ ОБЪЯСНЕНИЕ

    Наследование: Представьте, что у вас есть базовый класс Hero, который
    описывает общие свойства и действия героя. Классы Warrior и Mage
    "наследуют" эти свойства от Hero, что позволяет им использовать метод
    introduce и добавлять свои уникальные действия. Например, Warrior может
    атаковать с помощью меча, а Mage — колдовать с помощью посоха. Это как если
    бы у вас был базовый набор инструментов, который вы можете использовать и
    дополнять в зависимости от ситуации.

    Композиция: Вместо того чтобы наследовать свойства, класс может "включать"
    в себя другие классы. Например, Warrior имеет объект класса Sword, а Mage
    может использовать разные посохи (IceStaff, FireStaff, PoisonStaff). Это
    позволяет гибко менять оружие или посохи без изменения самого класса героя.
    Представьте, что у вас есть рюкзак, в который вы можете положить разные
    предметы — вы можете легко заменить один предмет на другой, не меняя сам
    рюкзак.

    Зачем это нужно: Наследование и композиция помогают организовать код так,
    чтобы его было легче понимать и изменять. Наследование полезно, когда у вас
    есть общие свойства, которые можно передать нескольким классам. Композиция
    позволяет гибко комбинировать разные части программы, делая её более
    адаптируемой к изменениям. Это как строить дом: сначала вы создаёте основу
    (наследование), а затем добавляете мебель и декор (композиция), чтобы
    сделать его уникальным.  """
